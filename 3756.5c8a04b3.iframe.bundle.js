/*! For license information please see 3756.5c8a04b3.iframe.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunk_ticketswap_solar=self.webpackChunk_ticketswap_solar||[]).push([[3756],{"./node_modules/@reach/observe-rect/dist/observe-rect.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Z:()=>__WEBPACK_DEFAULT_EXPORT__});var rafId,props=["bottom","height","left","right","top","width"],observedNodes=new Map,run=function run(){var changedStates=[];observedNodes.forEach((function(state,node){var newRect=node.getBoundingClientRect();(function rectChanged(a,b){return void 0===a&&(a={}),void 0===b&&(b={}),props.some((function(prop){return a[prop]!==b[prop]}))})(newRect,state.rect)&&(state.rect=newRect,changedStates.push(state))})),changedStates.forEach((function(state){state.callbacks.forEach((function(cb){return cb(state.rect)}))})),rafId=window.requestAnimationFrame(run)};const __WEBPACK_DEFAULT_EXPORT__=function observeRect(node,cb){return{observe:function observe(){var wasEmpty=0===observedNodes.size;observedNodes.has(node)?observedNodes.get(node).callbacks.push(cb):observedNodes.set(node,{rect:void 0,hasRectChanged:!1,callbacks:[cb]}),wasEmpty&&run()},unobserve:function unobserve(){var state=observedNodes.get(node);if(state){var index=state.callbacks.indexOf(cb);index>=0&&state.callbacks.splice(index,1),state.callbacks.length||observedNodes.delete(node),observedNodes.size||cancelAnimationFrame(rafId)}}}}},"./node_modules/@reach/tooltip/dist/reach-tooltip.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{zG:()=>TooltipPopup,lL:()=>useTooltip});var react=__webpack_require__("./node_modules/react/index.js"),react_namespaceObject=__webpack_require__.t(react,2);function canUseDOM(){return!("undefined"==typeof window||!window.document||!window.document.createElement)}function composeEventHandlers(theirHandler,ourHandler){return event=>{if(theirHandler&&theirHandler(event),!event.defaultPrevented)return ourHandler(event)}}function assignRef(ref,value){if(null!=ref)if(function isFunction(value){return!(!value||"[object Function]"!={}.toString.call(value))}(ref))ref(value);else try{ref.current=value}catch(error){throw new Error(`Cannot assign value "${value}" to ref "${ref}"`)}}function useComposedRefs(...refs){return(0,react.useCallback)((node=>{for(let ref of refs)assignRef(ref,node)}),refs)}function getOwnerDocument(element){return canUseDOM()?element?element.ownerDocument:document:null}function makeId(...args){return args.filter((val=>null!=val)).join("--")}var useIsomorphicLayoutEffect=canUseDOM()?react.useLayoutEffect:react.useEffect;var serverHandoffComplete=!1,id=0;function genId(){return++id}var maybeReactUseId=react_namespaceObject["useId".toString()];var react_dom=__webpack_require__("./node_modules/react-dom/index.js"),PortalImpl=({children,type="reach-portal",containerRef})=>{let mountNode=react.useRef(null),portalNode=react.useRef(null),forceUpdate=function useForceUpdate(){let[,dispatch]=(0,react.useState)(Object.create(null));return(0,react.useCallback)((()=>{dispatch(Object.create(null))}),[])}();return react.useEffect((()=>{null!=containerRef&&("object"==typeof containerRef&&"current"in containerRef?null==containerRef.current&&console.warn("@reach/portal: A ref was passed to the `containerRef` prop of a `Portal`, but no DOM node was attached to it. Be sure to pass the ref to a DOM component.\n\nIf you are forwarding the ref from another component, be sure to use the React.forwardRef API. See https://reactjs.org/docs/forwarding-refs.html."):console.warn("@reach/portal: Invalid value passed to the `containerRef` of a `Portal`. The portal will be appended to the document body, but if you want to attach it to another DOM node you must pass a valid React ref object to `containerRef`."))}),[containerRef]),useIsomorphicLayoutEffect((()=>{if(!mountNode.current)return;let ownerDocument=mountNode.current.ownerDocument,body=containerRef?.current||ownerDocument.body;return portalNode.current=ownerDocument?.createElement(type),body.appendChild(portalNode.current),forceUpdate(),()=>{portalNode.current&&body&&body.removeChild(portalNode.current)}}),[type,forceUpdate,containerRef]),portalNode.current?(0,react_dom.createPortal)(children,portalNode.current):react.createElement("span",{ref:mountNode})},Portal=({unstable_skipInitialRender,...props})=>{let[hydrated,setHydrated]=react.useState(!1);return react.useEffect((()=>{unstable_skipInitialRender&&setHydrated(!0)}),[unstable_skipInitialRender]),unstable_skipInitialRender&&!hydrated?null:react.createElement(PortalImpl,{...props})};Portal.displayName="Portal";var VisuallyHidden=react.forwardRef((function VisuallyHidden2({as:Comp="span",style={},...props},ref){return react.createElement(Comp,{ref,style:{border:0,clip:"rect(0 0 0 0)",height:"1px",margin:"-1px",overflow:"hidden",padding:0,position:"absolute",width:"1px",whiteSpace:"nowrap",wordWrap:"normal",...style},...props})}));VisuallyHidden.displayName="VisuallyHidden";var observe_rect_esm=__webpack_require__("./node_modules/@reach/observe-rect/dist/observe-rect.esm.js");function reach_utils_canUseDOM(){return!("undefined"==typeof window||!window.document||!window.document.createElement)}function reach_utils_isBoolean(value){return"boolean"==typeof value}function reach_utils_isFunction(value){return!(!value||"[object Function]"!={}.toString.call(value))}var reach_utils_useIsomorphicLayoutEffect=reach_utils_canUseDOM()?react.useLayoutEffect:react.useEffect;function useRect(nodeRef,observeOrOptions,deprecated_onChange){let observe,onChange;reach_utils_isBoolean(observeOrOptions)?observe=observeOrOptions:(observe=observeOrOptions?.observe??!0,onChange=observeOrOptions?.onChange),reach_utils_isFunction(deprecated_onChange)&&(onChange=deprecated_onChange),react.useEffect((()=>{reach_utils_isBoolean(observeOrOptions)&&console.warn("Passing `observe` as the second argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `observe` property as the second argument (`useRect(ref, { observe })`).\nSee https://reach.tech/rect#userect-observe")}),[observeOrOptions]),react.useEffect((()=>{reach_utils_isFunction(deprecated_onChange)&&console.warn("Passing `onChange` as the third argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `onChange` property as the second argument (`useRect(ref, { onChange })`).\nSee https://reach.tech/rect#userect-onchange")}),[deprecated_onChange]);let[element,setElement]=react.useState(nodeRef.current),initialRectIsSet=react.useRef(!1),initialRefIsSet=react.useRef(!1),[rect,setRect]=react.useState(null),onChangeRef=react.useRef(onChange);return reach_utils_useIsomorphicLayoutEffect((()=>{onChangeRef.current=onChange,nodeRef.current!==element&&setElement(nodeRef.current)})),reach_utils_useIsomorphicLayoutEffect((()=>{element&&!initialRectIsSet.current&&(initialRectIsSet.current=!0,setRect(element.getBoundingClientRect()))}),[element]),reach_utils_useIsomorphicLayoutEffect((()=>{if(!observe)return;let elem=element;if(initialRefIsSet.current||(initialRefIsSet.current=!0,elem=nodeRef.current),!elem)return void console.warn("You need to place the ref");let observer=(0,observe_rect_esm.Z)(elem,(rect2=>{onChangeRef.current?.(rect2),setRect(rect2)}));return observer.observe(),()=>{observer.unobserve()}}),[observe,element,nodeRef]),rect}var restTimeout,leavingVisibleTimer,chart={initial:"IDLE",states:{IDLE:{enter:clearContextId,on:{MOUSE_ENTER:"FOCUSED",FOCUS:"VISIBLE"}},FOCUSED:{enter:function startRestTimer(){window.clearTimeout(restTimeout),restTimeout=window.setTimeout((()=>{send({type:"REST"})}),100)},leave:function clearRestTimer(){window.clearTimeout(restTimeout)},on:{MOUSE_MOVE:"FOCUSED",MOUSE_LEAVE:"IDLE",MOUSE_DOWN:"DISMISSED",BLUR:"IDLE",REST:"VISIBLE"}},VISIBLE:{on:{FOCUS:"FOCUSED",MOUSE_ENTER:"FOCUSED",MOUSE_LEAVE:"LEAVING_VISIBLE",BLUR:"LEAVING_VISIBLE",MOUSE_DOWN:"DISMISSED",SELECT_WITH_KEYBOARD:"DISMISSED",GLOBAL_MOUSE_MOVE:"LEAVING_VISIBLE"}},LEAVING_VISIBLE:{enter:function startLeavingVisibleTimer(){window.clearTimeout(leavingVisibleTimer),leavingVisibleTimer=window.setTimeout((()=>send({type:"TIME_COMPLETE"})),500)},leave:()=>{!function clearLeavingVisibleTimer(){window.clearTimeout(leavingVisibleTimer)}(),clearContextId()},on:{MOUSE_ENTER:"VISIBLE",FOCUS:"VISIBLE",TIME_COMPLETE:"IDLE"}},DISMISSED:{leave:()=>{clearContextId()},on:{MOUSE_LEAVE:"IDLE",BLUR:"IDLE"}}}},state={value:chart.initial,context:{id:null}},subscriptions=[];function clearContextId(){state.context.id=null}function useTooltip({id:idProp,onPointerEnter,onPointerMove,onPointerLeave,onPointerDown,onMouseEnter,onMouseMove,onMouseLeave,onMouseDown,onFocus,onBlur,onKeyDown,disabled,ref:forwardedRef,DEBUG_STYLE}={}){let id=String(function useId(providedId){if(void 0!==maybeReactUseId){let generatedId=maybeReactUseId();return providedId??generatedId}let initialId=providedId??(serverHandoffComplete?genId():null),[id2,setId]=react.useState(initialId);return useIsomorphicLayoutEffect((()=>{null===id2&&setId(genId())}),[]),react.useEffect((()=>{!1===serverHandoffComplete&&(serverHandoffComplete=!0)}),[]),providedId??id2??void 0}(idProp)),[isVisible,setIsVisible]=react.useState(!!DEBUG_STYLE||isTooltipVisible(id,!0)),ownRef=react.useRef(null),ref=useComposedRefs(forwardedRef,ownRef),triggerRect=useRect(ownRef,{observe:isVisible});function wrapMouseEvent(theirHandler,ourHandler){return"undefined"!=typeof window&&"PointerEvent"in window?theirHandler:composeEventHandlers(theirHandler,ourHandler)}function wrapPointerEventHandler(handler){return function onPointerEvent(event){"mouse"===event.pointerType&&handler(event)}}function handleMouseEnter(){send({type:"MOUSE_ENTER",id})}function handleMouseMove(){send({type:"MOUSE_MOVE",id})}function handleMouseLeave(){send({type:"MOUSE_LEAVE"})}function handleMouseDown(){state.context.id===id&&send({type:"MOUSE_DOWN"})}return react.useEffect((()=>function subscribe(fn){return subscriptions.push(fn),()=>{subscriptions.splice(subscriptions.indexOf(fn),1)}}((()=>{setIsVisible(isTooltipVisible(id))}))),[id]),react.useEffect((()=>{let ownerDocument=getOwnerDocument(ownRef.current);function listener(event){"Escape"!==event.key&&"Esc"!==event.key||"VISIBLE"!==state.value||send({type:"SELECT_WITH_KEYBOARD"})}return ownerDocument.addEventListener("keydown",listener),()=>ownerDocument.removeEventListener("keydown",listener)}),[]),function useDisabledTriggerOnSafari({disabled,isVisible,ref}){react.useEffect((()=>{if("undefined"==typeof window||!("PointerEvent"in window)||!disabled||!isVisible)return;let ownerDocument=getOwnerDocument(ref.current);function handleMouseMove(event){isVisible&&(event.target instanceof Element&&event.target.closest("[data-reach-tooltip-trigger][data-state='tooltip-visible']")||send({type:"GLOBAL_MOUSE_MOVE"}))}return ownerDocument.addEventListener("mousemove",handleMouseMove),()=>{ownerDocument.removeEventListener("mousemove",handleMouseMove)}}),[disabled,isVisible,ref])}({disabled,isVisible,ref:ownRef}),[{"aria-describedby":isVisible?makeId("tooltip",id):void 0,"data-state":isVisible?"tooltip-visible":"tooltip-hidden","data-reach-tooltip-trigger":"",ref,onPointerEnter:composeEventHandlers(onPointerEnter,wrapPointerEventHandler(handleMouseEnter)),onPointerMove:composeEventHandlers(onPointerMove,wrapPointerEventHandler(handleMouseMove)),onPointerLeave:composeEventHandlers(onPointerLeave,wrapPointerEventHandler(handleMouseLeave)),onPointerDown:composeEventHandlers(onPointerDown,wrapPointerEventHandler(handleMouseDown)),onMouseEnter:wrapMouseEvent(onMouseEnter,handleMouseEnter),onMouseMove:wrapMouseEvent(onMouseMove,handleMouseMove),onMouseLeave:wrapMouseEvent(onMouseLeave,handleMouseLeave),onMouseDown:wrapMouseEvent(onMouseDown,handleMouseDown),onFocus:composeEventHandlers(onFocus,(function handleFocus(){window.__REACH_DISABLE_TOOLTIPS||send({type:"FOCUS",id})})),onBlur:composeEventHandlers(onBlur,(function handleBlur(){state.context.id===id&&send({type:"BLUR"})})),onKeyDown:composeEventHandlers(onKeyDown,(function handleKeyDown(event){"Enter"!==event.key&&" "!==event.key||send({type:"SELECT_WITH_KEYBOARD"})}))},{id,triggerRect,isVisible},isVisible]}var Tooltip=react.forwardRef((function({children,label,ariaLabel:DEPRECATED_ariaLabel,id,DEBUG_STYLE,...props},forwardedRef){let child=react.Children.only(children);react.useEffect((()=>{DEPRECATED_ariaLabel&&console.warn("The `ariaLabel prop is deprecated and will be removed from @reach/tooltip in a future version of Reach UI. Please use `aria-label` instead.")}),[DEPRECATED_ariaLabel]);let[trigger,tooltip]=useTooltip({id,onPointerEnter:child.props.onPointerEnter,onPointerMove:child.props.onPointerMove,onPointerLeave:child.props.onPointerLeave,onPointerDown:child.props.onPointerDown,onMouseEnter:child.props.onMouseEnter,onMouseMove:child.props.onMouseMove,onMouseLeave:child.props.onMouseLeave,onMouseDown:child.props.onMouseDown,onFocus:child.props.onFocus,onBlur:child.props.onBlur,onKeyDown:child.props.onKeyDown,disabled:child.props.disabled,ref:child.ref,DEBUG_STYLE});return react.createElement(react.Fragment,null,react.cloneElement(child,trigger),react.createElement(TooltipPopup,{ref:forwardedRef,label,"aria-label":DEPRECATED_ariaLabel,...tooltip,...props}))}));Tooltip.displayName="Tooltip";var TooltipPopup=react.forwardRef((function TooltipPopup2({label,ariaLabel:DEPRECATED_ariaLabel,isVisible,id,...props},forwardRef2){return isVisible?react.createElement(Portal,null,react.createElement(TooltipContent,{ref:forwardRef2,label,"aria-label":DEPRECATED_ariaLabel,isVisible,...props,id:makeId("tooltip",String(id))})):null}));TooltipPopup.displayName="TooltipPopup";var TooltipContent=react.forwardRef((function TooltipContent2({ariaLabel,"aria-label":realAriaLabel,as:Comp="div",id,isVisible,label,position=positionTooltip,style,triggerRect,...props},forwardedRef){let hasAriaLabel=null!=(realAriaLabel||ariaLabel),ownRef=react.useRef(null),ref=useComposedRefs(forwardedRef,ownRef),tooltipRect=useRect(ownRef,{observe:isVisible});return react.createElement(react.Fragment,null,react.createElement(Comp,{role:hasAriaLabel?void 0:"tooltip",...props,ref,"data-reach-tooltip":"",id:hasAriaLabel?void 0:id,style:{...style,...getStyles(position,triggerRect,tooltipRect)}},label),hasAriaLabel&&react.createElement(VisuallyHidden,{role:"tooltip",id},realAriaLabel||ariaLabel))}));function getStyles(position,triggerRect,tooltipRect){return!tooltipRect?{visibility:"hidden"}:position(triggerRect,tooltipRect)}TooltipContent.displayName="TooltipContent";var positionTooltip=(triggerRect,tooltipRect,offset=8)=>{let{width:windowWidth,height:windowHeight}=function getDocumentDimensions(element){let ownerDocument=getOwnerDocument(element),ownerWindow=ownerDocument.defaultView||window;return ownerDocument?{width:ownerDocument.documentElement.clientWidth??ownerWindow.innerWidth,height:ownerDocument.documentElement.clientHeight??ownerWindow.innerHeight}:{width:0,height:0}}();if(!triggerRect||!tooltipRect)return{};let collisions={top:triggerRect.top-tooltipRect.height<0,right:windowWidth<triggerRect.left+tooltipRect.width,bottom:windowHeight<triggerRect.bottom+tooltipRect.height+offset,left:triggerRect.left-tooltipRect.width<0},directionUp=collisions.bottom&&!collisions.top;return{left:collisions.right&&!collisions.left?`${triggerRect.right-tooltipRect.width+window.pageXOffset}px`:`${triggerRect.left+window.pageXOffset}px`,top:directionUp?`${triggerRect.top-offset-tooltipRect.height+window.pageYOffset}px`:`${triggerRect.top+offset+triggerRect.height+window.pageYOffset}px`}};function send(event){let{value,context,changed}=function transition(currentState,event){let stateDef=chart.states[currentState.value],nextState=stateDef&&stateDef.on&&stateDef.on[event.type];if(!nextState)return{...currentState,changed:!1};stateDef&&stateDef.leave&&stateDef.leave(currentState.context,event);const{type:_,...payload}=event;let context={...state.context,...payload},nextStateValue="string"==typeof nextState?nextState:nextState.target,nextDef=chart.states[nextStateValue];nextDef&&nextDef.enter&&nextDef.enter(currentState.context,event);return{value:nextStateValue,context,changed:!0}}(state,event);changed&&(state={value,context},function notify(){subscriptions.forEach((fn=>fn(state)))}())}function isTooltipVisible(id,initial){return state.context.id===id&&(initial?"VISIBLE"===state.value:"VISIBLE"===state.value||"LEAVING_VISIBLE"===state.value)}}}]);